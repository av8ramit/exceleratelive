####################################################################################################################################################  
#                                                                                                                                                  #
# This file has been generated by Amit Patankar:                                                                                                   #
#     Created by              : amit.patankar                                                                                                      #    
#     Created on              : 08-08-2013                                                                                                         #
#     Directory               : /Desktop/                                                                                                          #
#     Purpose                 : This file holds all the command functions.                                                                         #
#                                                                                                                                                  #
#################################################################################################################################################### 

import csv
from Values import *
from Key import *
from Answer import *
from User import *
from Class import *
from Scored import *
import datetime

def clear(n):
    for i in range(0,n):
        print (n)



def class_missed_qs_array(classname):
    X = []
    classnm = classname
    classwritingqs = []
    classreadingqs = []
    classmathqs = []
    section = []


    for name in classnm.students:
        filename = user_filename(name, classnm.name)
        u = load_user(name, filename, classnm.name)
        index = 0
        wqs = []
        rqs = []
        mqs = []
        del CLASS_MISSED_WRITING[:]
        del CLASS_MISSED_READING[:]
        del CLASS_MISSED_MATH[:]
        for test in u.tests_taken:
            wqs.append(test.missed_questions[WRITING_TYPE])
            rqs.append(test.missed_questions[READING_TYPE])
            mqs.append(test.missed_questions[MATH_TYPE])

            index = index + 1
        for q in (wqs[index-1]):
            question, answer = q
            classwritingqs.append(question) #add missed question object to class list
        
            
        for q in (rqs[index-1]):
            question, answer = q
            classreadingqs.append(question) #add missed question object to class list
            #print("r: " + question)
        for q in (mqs[index-1]):
            question, answer = q
            classmathqs.append(question) #add missed question object to class list    
            #print("m: " + question)

    for question in classwritingqs:
        frequency = classwritingqs.count(question)
        #print(str(frequency) + " writing " + question)
        if question in CLASS_MISSED_WRITING:
            pass
        else:
            CLASS_MISSED_WRITING.append(Class_Question(question,frequency)) 
        for i in range(frequency):
            classwritingqs.remove(question)
            

    for question in classreadingqs:
        frequency = classreadingqs.count(question)
        #print(str(frequency) + " r " + question)
        if question in CLASS_MISSED_READING:
            pass
        else:
            CLASS_MISSED_READING.append(Class_Question(question,frequency))
        for i in range(frequency):
            classreadingqs.remove(question)
            

    for question in classmathqs:
        frequency = classmathqs.count(question)
        #print(str(frequency) + " m " + question) 
        if question in CLASS_MISSED_MATH:
            pass
        else:
            CLASS_MISSED_MATH.append(Class_Question(question,frequency))
        for i in range(frequency):
            classmathqs.remove(question)
            


    CLASS_MISSED_WRITING.sort(key=lambda question: question.frequency, reverse = True)
    CLASS_MISSED_READING.sort(key=lambda question: question.frequency, reverse = True)
    CLASS_MISSED_MATH.sort(key=lambda question: question.frequency, reverse = True)

    '''
    for item in missedwriting:

        print(str(item.question) + " Frequency: " + str(item.frequency))

    print()
    for item in missedreading:

        print(str(item.question) +  " Frequency: " + str(item.frequency))
    print()
    for item in missedmath:

        print(str(item.question) + " Frequency: " + str(item.frequency))
    '''
def new_class(name):   #new class function creates a new class object with no students in it
    c = Class(name)      #instantiate class object 
    mkdir(class_directory(name))
    return c             #return class object - used in Console.py 

def load_class(name):   #load class function creates a new class object and then loads all applicable students
    c = Class(name)    #instantiate class object
    c.students = list_users_array(name) # assign array of student names as strings to class object's 'students' attribute
    return c            #return class object with all applicable users - used in Console.py


def new_user(name, c):    # new user function creates a user object and builds it
    #directory = user_directory(name, c)     
    #disable deleting old directory to make a new one
    #if (file_exists(directory)):
    #    rmdir(directory)
    
    u = User(name, c)   #instantiate a user object with parameters username and user's classname  
    u.build()        #call user object method build() from User.py
    return u           # return built user object - used in Console.py 


def load_user(name, filename, classname):   #load user function creates a user object and recreates user data
    u = User(name, classname)       #instantiate a user object with parameters username and user's classname 
    u.name = name         #assign user object 'name' attribute the username
    u.recreate_user(filename)  #call user object method recreate_user() from User.py
    return u                  #return recreated user object - used in Console.py 


def delete_user(name, c):   #delete user function removes the users directory
    rmdir(user_directory(name, c))            #removes directory

def grade(u, filename):  
    pa = parse_answers(filename)
    u.grade(pa)

def list_classes(): # function that returns an array of class names - used in GUI.py dropdown button
    array = []               
    a = os.listdir(class_directory(''))   # a is all classes in class directory
    for i in a:                            # for each class in all class directories 
        if i[0] == '.':
            continue
        if file_exists(class_directory(i)):  # if class exists 
            array.append(i)                    # add to array 
    return array                     #return array of class names 

def list_tests():
    a = os.listdir(test_directory(''))
    array = []
    #print ("Here are the available test_ids:")
    for i in a:
        if valid_test_id(i):
            #print (i)
            array.append(i)
    return array

def list_users(c):
    array = []
    a = os.listdir(class_directory(c))
    return str(a)

def list_users_array(c):
    array = []
    a = os.listdir(class_directory(c))
    for i in a:
        if file_exists(user_filename(i, c)):
            array.append(i)
    return array

def make_answer_sheet(u, test_id):
    filename = test_id
    lines = []
    label_vector = "Number:,Answer:" + endl
    lines.append(test_id + " Answer Sheet" + endl)
    lines.append("Name:," + u.name + endl)
    lines.append("Date:," + datetime_converter(str(datetime.date.today())) + endl)
    lines.append("Essay:,7" + endl)
    lines.append(label_vector)
    with open(test_directory(filename) + DIR_SEP + KEYFILE, 'rU') as f:
        reader = csv.reader(f)
        for row in reader:
            if row != KEY_VECTOR:
                lines.append("Section " + str(row[0]) + ":" + endl)
                for j in range(1,int(row[2]) + 1):
                    lines.append(str(j) + ",?")
                    lines.append(endl)
    FILE = open(user_directory(u.name, u.c) + DIR_SEP + test_id + ".csv", "w")
    FILE.writelines(lines)
    FILE.close()

def parse_answers(filename):
    with open(filename, 'rU') as f:
        reader = csv.reader(f)
        id_set = False
        counter = 1
        test = None
        current_section = None

        for row in reader:
            counter +=1
            if row == ANSWER_VECTOR:
                continue
            elif row == []:
                continue
            elif row[0] == "Name:":
                test.add_name(row[1])
            elif row[0] == "Date:":
                test.add_date(row[1])
            elif row[0] == "Essay:":
                test.add_essay(int(row[1]))
            elif row[0] == "": #blanks
                continue
            elif not id_set:
                test_id = row[0].split(' ')[0]
                id_set = True
                test = Answered_Test(test_id)

            elif len(row) > 0 and row[0].split(' ')[0] == "Section":
                index = row[0].split(' ')[1][:-1]
                if current_section != None:
                    test.add_section(current_section)

                current_section = Answered_Section(int(index))

            elif len(row) != 0:
                q_num = int(row[0])
                answer = row[1]
                q = Answered_Question(q_num, answer)
                current_section.add_question(q)
    test.add_section(current_section)
    return test

def simple_report(u):
    u.simple_HTML()

def advanced_report(u):
    u.advanced_HTML()

def graph_report(u):
    u.graph_HTML()

def section_report(u):
    u.section_HTML(WRITING_TYPE)
    u.section_HTML(READING_TYPE)
    u.section_HTML(MATH_TYPE)


#def valid_test(filename):
    
